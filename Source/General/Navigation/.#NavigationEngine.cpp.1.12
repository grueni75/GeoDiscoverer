//============================================================================
// Name        : NavigationEngine.cpp
// Author      : Matthias Gruenewald
// Copyright   : Copyright 2010 Matthias Gruenewald
//
// This file is part of GeoDiscoverer.
//
// GeoDiscoverer is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// GeoDiscoverer is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with GeoDiscoverer.  If not, see <http://www.gnu.org/licenses/>.
//
//============================================================================


#include <Core.h>

namespace GEODISCOVERER {

// Constructor
NavigationEngine::NavigationEngine() {

  // Init variables
  locationOutdatedThreshold=core->getConfigStore()->getIntValue("Navigation","locationOutdatedThreshold","Duration in milliseconds after which a position will be discarded.",120*1000);
  locationSignificantlyInaccurateThreshold=core->getConfigStore()->getIntValue("Navigation","locationSignificantlyInaccurateThreshold","Distance in meter that indicates a significantly less accurate position.",100);
  trackRecordingMinDistance=core->getConfigStore()->getDoubleValue("Navigation","trackRecordingMinDistance","Required minimum distance in meter to the last track point such that the point is added to the track.",10);
  //trackRecordingMinBearing=core->getConfigStore()->getDoubleValue("Navigation","trackRecordingMinBearing","Required minimum bearing in degree to the last track point such that the point is added to the track.",10);
  prevPointMeetsCriterias=false;
  recordedTrackMutex=core->getThread()->createMutex();
  routesMutex=core->getThread()->createMutex();
  recordTrack=false;

  // Create the track directory if it does not exist
  struct stat st;
  if (stat(getTrackPath().c_str(), &st) != 0)
  {
    if (mkdir(getTrackPath().c_str(),S_IRWXU | S_IRWXG | S_IRWXO)!=0) {
      FATAL("can not create track directory!",NULL);
      return;
    }
  }

  // Init the remaining part
  init();
}

// Destructor
NavigationEngine::~NavigationEngine() {
  deinit();
  core->getThread()->destroyMutex(recordedTrackMutex);
  core->getThread()->destroyMutex(routesMutex);
}

// Inits the engine
void NavigationEngine::init() {

  ConfigStore *c=core->getConfigStore();

  // Deinit first
  deinit();

  // Set the color of the recorded track
  lockRecordedTrack();
  recordedTrack.setColor(c->getGraphicColorValue("Navigation/trackColor","recorded track",GraphicColor(255,127,0,255)));

  // Load the last recorded track if it does exist
  FILE *in;
  std::string lastRecordedTrackFilename=c->getStringValue("Navigation","lastRecordedTrackFilename","Filename of the last recorded track.","");
  std::string filepath=recordedTrack.getGpxFilefolder()+"/"+lastRecordedTrackFilename;
  if ((lastRecordedTrackFilename!="")&&(in=fopen(filepath.c_str(),"r"))) {
    fclose(in);
    recordedTrack.setGpxFilename(lastRecordedTrackFilename);
    recordedTrack.readGPXFile();
  } else {
    c->setStringValue("Navigation","lastRecordedTrackFilename",recordedTrack.getGpxFilename());
  }
  unlockRecordedTrack();

  // Load any routes
  lockRoutes();
  std::string path="Route";
  std::list<std::string> routeNumbers=c->getAttributeValues(path,"number");
  std::list<std::string>::iterator j;
  for(std::list<std::string>::iterator i=routeNumbers.begin();i!=routeNumbers.end();i++) {
    std::string routePath=path + "[@number='" + *i + "']";
    NavigationPath *route=new NavigationPath();
    if (!route) {
      FATAL("can not create route",NULL);
      return;
    }
    route->setColor(c->getGraphicColorValue(path + "/Color","Color of the route",GraphicColor(255,255,0,255)));
    route->setName(c->getStringValue(path,"filename","GPX filename of the route","unknown.gpx"));
    route->setDescription("route number " + *i);
    route->setGpxFilefolder(getRoutePath());
    route->setGpxFilename(route->getName());
    if (!(route->readGPXFile())) {
      delete route;
    } else {
      routes.push_back(route);
    }
  }
  unlockRoutes();

}

// Deinits the engine
void NavigationEngine::deinit() {

  // Save the track first
  lockRecordedTrack();
  recordedTrack.writeGPXFile();
  recordedTrack=NavigationPath();
  unlockRecordedTrack();

  // Free all routes
  lockRoutes();
  for (std::list<NavigationPath*>::iterator i=routes.begin();i!=routes.end();i++) {
    delete *i;
  }
  routes.clear();
  unlockRoutes();
}


// Updates the current location
void NavigationEngine::newLocationFix(MapPosition newLocationPos) {

  bool updatePos=false;
  bool isNewer=false;

  // Check if the new fix is older or newer
  if (newLocationPos.getTimestamp()>locationPos.getTimestamp()) {

    isNewer=true;

    // If the new fix is significantly newer, use it
    if (newLocationPos.getTimestamp()-locationPos.getTimestamp()>=locationOutdatedThreshold) {
      updatePos=true;
    }

  } else {

    // If it is significantly older, discard it
    if (locationPos.getTimestamp()-newLocationPos.getTimestamp()>=locationOutdatedThreshold) {
      return;
    }

  }

  // If the new fix is more accurate, use it
  int accuracyDiff=(int)newLocationPos.getAccuracy()-locationPos.getAccuracy();
  if (accuracyDiff<0) {
    updatePos=true;
  } else {

    // Is the new fix newer?
    if (isNewer) {

      // If the new fix is not less accurate, use it
      if (accuracyDiff==0) {
        updatePos=true;
      } else {

        // If the new fix is from the same provider and is not significantly less accurate, use it
        if ((newLocationPos.getSource()==locationPos.getSource())&&(newLocationPos.getAccuracy()<=locationSignificantlyInaccurateThreshold)) {
          updatePos=true;
        }

      }
    }
  }

  // Update the position
  if (updatePos) {
    DEBUG("new location fix received: source=%s lng=%f lat=%f hasAltitude=%d altitude=%f hasBearing=%d bearing=%f hasSpeed=%d speed=%f hasAccuracy=%d accuracy=%f",
          newLocationPos.getSource().c_str(),
          newLocationPos.getLng(),
          newLocationPos.getLat(),
          newLocationPos.getHasAltitude(),
          newLocationPos.getAltitude(),
          newLocationPos.getHasBearing(),
          newLocationPos.getBearing(),
          newLocationPos.getHasSpeed(),
          newLocationPos.getSpeed(),
          newLocationPos.getHasAccuracy(),
          newLocationPos.getAccuracy());

    // If the new fix has no heading, keep the previous one
    if (!newLocationPos.getHasBearing()&&locationPos.getHasBearing()) {
      newLocationPos.setHasBearing(true);
      newLocationPos.setBearing(locationPos.getBearing());
    }

    // Store the new fix
    locationPos=newLocationPos;
    MapPosition *pos=core->getMapEngine()->lockLocationPos();
    *pos=locationPos;
    core->getMapEngine()->unlockLocationPos();

    // Update the current track
    updateTrack();
  }

}

// Updates the currently recorded track
void NavigationEngine::updateTrack() {

  bool pointMeetsCriterias=false;
  bool addPoint=false;
  bool replacePoint=false;
  double distance=0;

  // Get access to the recorded track
  core->getThread()->lockMutex(recordedTrackMutex);

  // Check if recording is enabled
  if (!recordTrack) {
    core->getThread()->unlockMutex(recordedTrackMutex);
    return;
  }

  // If the track was just loaded, we need to add this point as a stable one
  if (recordedTrack.getHasBeenLoaded()) {
    pointMeetsCriterias=true;
    prevPointMeetsCriterias=true;
    recordedTrack.setHasBeenLoaded(false);
  } else {

    // Check if the point meets the criteras to become part of the path
    if (recordedTrack.getHasLastPoint()) {
      MapPosition lastPoint=recordedTrack.getLastPoint();
      /*MapPosition secondLastPoint=recordedTrack.getSecondLastPoint();
      bool bearingDiffLargeEnough=false;
      if (recordedTrack.getHasSecondLastPoint()) {
        double t1=secondLastPoint.computeBearing(locationPos);
        double t2=lastPoint.computeBearing(locationPos);
        bearingDiff=fabs(t2-t1);
        if (bearingDiff>trackRecordingMinBearing)
          bearingDiffLargeEnough=true;
      } else {
        bearingDiffLargeEnough=true;
      }*/
      distance=lastPoint.computeDistance(locationPos);
      //DEBUG("secondLastPoint=(%f,%f) lastPoint=(%f,%f) locationPos=(%f,%f) distance=%.2f bearingDiff=%.2f",secondLastPoint.getLat(),secondLastPoint.getLng(),lastPoint.getLat(),lastPoint.getLng(),locationPos.getLat(),locationPos.getLng(),distance,bearingDiff);
      //if ((distance>=trackRecordingMinDistance)||(bearingDiffLargeEnough))
      if (distance>=trackRecordingMinDistance)
        pointMeetsCriterias=true;
    } else {
      pointMeetsCriterias=true;
    }
  }

  // If the list has no end point, the point need to be added
  if (!recordedTrack.getHasLastPoint()) {
    addPoint=true;
  } else {

    // If the last point did meet the criterias
    // a new point need to be added
    if (prevPointMeetsCriterias) {
      addPoint=true;
    } else {

      // The last point need to be replaced always
      replacePoint=true;

    }
  }

  // Add a new point or replace the last point
  //DEBUG("addPoint=%d replacePoint=%d pointMeetsCriterias=%d",addPoint,replacePoint,pointMeetsCriterias);
  if (addPoint) {
    DEBUG("adding new point (%f,%f): distance=%.2f pointMeetsCriterias=%d",locationPos.getLat(),locationPos.getLng(),distance,pointMeetsCriterias);
    recordedTrack.addEndPosition(locationPos,pointMeetsCriterias);
  }
  if (replacePoint) {
    DEBUG("replacing last point (%f,%f): distance=%.2f pointMeetsCriterias=%d",locationPos.getLat(),locationPos.getLng(),distance,pointMeetsCriterias);
    recordedTrack.replaceEndPosition(locationPos,pointMeetsCriterias);
  }

  // Remember the decision for this point
  prevPointMeetsCriterias=pointMeetsCriterias;

  // Free the recorded track
  core->getThread()->unlockMutex(recordedTrackMutex);

}

// Saves the recorded track if required
void NavigationEngine::backup() {

  // Store the recorded track
  core->getThread()->lockMutex(recordedTrackMutex);
  recordedTrack.writeGPXFile();
  core->getThread()->unlockMutex(recordedTrackMutex);

}

// Switches the track recording
void NavigationEngine::setRecordTrack(bool recordTrack)
{
  // Interrupt the track if there is a previous point
  core->getThread()->lockMutex(recordedTrackMutex);
  if ((recordTrack)&&(!this->recordTrack)) {
    if (recordedTrack.getHasLastPoint()) {
      if (recordedTrack.getLastPoint()!=NavigationPath::getPathInterruptedPos()) {
        if (prevPointMeetsCriterias) {
          recordedTrack.addEndPosition(NavigationPath::getPathInterruptedPos(),true);
        } else {
          recordedTrack.replaceEndPosition(NavigationPath::getPathInterruptedPos(),true);
        }
        prevPointMeetsCriterias=true;
      }
    }
  }
  this->recordTrack=recordTrack;
  WARNING("check that track interruption works and can be loaded",NULL);
  core->getThread()->unlockMutex(recordedTrackMutex);
}

// Creates a new track
void NavigationEngine::createNewTrack() {
  lockRecordedTrack();
  recordedTrack.writeGPXFile();
  recordedTrack=NavigationPath();
  recordedTrack.setColor(core->getConfigStore()->getGraphicColorValue("Navigation/trackColor","recorded track",GraphicColor(255,127,0,255)));
  core->getConfigStore()->setStringValue("Navigation","lastRecordedTrackFilename",recordedTrack.getGpxFilename());
  prevPointMeetsCriterias=false;
  unlockRecordedTrack();
}

}
